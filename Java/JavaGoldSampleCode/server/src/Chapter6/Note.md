
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [Chapter6](#chapter6)
  - [クラス定義とオブジェクトの生成・使用](#クラス定義とオブジェクトの生成使用)
    - [クラスとオブジェクト](#クラスとオブジェクト)
    - [コンストラクタ](#コンストラクタ)
    - [オーバーロード](#オーバーロード)
    - [static変数とstaticメソッド](#static変数とstaticメソッド)
    - [メンバ変数の初期化](#メンバ変数の初期化)
    - [アクセス修飾子とカプセル化](#アクセス修飾子とカプセル化)
    - [ガベージコレクタ](#ガベージコレクタ)

<!-- /code_chunk_output -->


# Chapter6

## クラス定義とオブジェクトの生成・使用

----
### クラスとオブジェクト

- classには属性となる変数と、操作となるメソッドを定義する
- javaでは<b>1つのソースファイルに、必ず1つ以上のクラスを定義する</b>
コンパイルすると定義したクラスの数だけクラスファイルが生成される

- クラス内に定義した変数のことを<b>メンバ変数(フィールド)</b>と呼ぶ。
メンバ変数には<b>インスタンス変数</b>と<b>static変数</b>の2種類がある。

  | メンバ変数の種類 |  |
  |:-----|:---|
  | インスタンス変数 | オブジェクトごとに存在する変数 |
  | static変数 | クラスに対して存在する変数 |

- 戻り値がないメソッドの場合は`void`を指定する必要があることに注意
  ```java 
  public void Foo() { }
  ```

- クラスをもとにオブジェクトを作成すること⇒<b>インスタンス化</b>
  ```java
  データ型 変数名 = new クラス名();
  ```

- クラス定義の直下で宣言する変数⇒<b>メンバ変数</b>
- if文やfor文など、あるブロックの中で宣言された変数やメソッドの引数リストで宣言された変数⇒<b>ローカル変数</b>

- メンバ変数は、クラス内のどこからでもアクセスできるが、ローカル変数は宣言したブロック内でしかアクセスできない。

---
### コンストラクタ

- インスタンス化の時に最初に呼び出されるブロック。以下制限あり。
  - 名前がクラス名と同じ
  - 戻り値をもたない

- コンストラクタが明示的に定義されていない場合、自動的にコンストラクタが追加される仕組みになっている。
自動的に追加されたコンストラクタは引数を持たず、実装も空⇒<b>デフォルトコンストラクタ</b>

- デフォルトコンストラクタは、クラスに1つもコンストラクタを定義しなかった場合のみ、コンパイルのタイミングで追加される。

---
### オーバーロード

- Java言語では1つのクラス内に、同じ名前のメソッドやコンストラクタを複数定義することができる⇒<b>オーバーロード</b>

- オーバーロードでは、引数の並び、型、数が異なっていることが必要。
(戻り値、アクセス修飾子は条件に含まれていない=同じであっても異なっていてもOK)


---
### static変数とstaticメソッド

- オブジェクトが個別に値を持つ変数⇒インスタンス変数
もう一つのメンバ変数⇒static変数
  ||メンバ変数|メンバメソッド|
  |:---|:---|:---|
  |インスタンスメンバ|インスタンス変数|インスタンスメソッド|
  |staticメンバ|static変数|staticメソッド|

- インスタンスメンバは、そのクラスをインスタンス化すると、各オブジェクトの中に個々の領域として用意される。
- staticメンバは複数インスタンス化されても1箇所で領域が確保される。
⇒1つのstaticメンバに対し、領域は1つしか用意されない

---
### メンバ変数の初期化

- メンバ変数の初期値
  |データ型|値|
  |:---|:---|
  |byte, short, int, long|0|
  |float, double|0.0|
  |char|\u0000|
  |boolean|false|
  |参照型|null|

- <b>ローカル変数は暗黙で初期化されることはない</b>

- メンバ間アクセスのルール
  - クラス内で定義したインスタンスメンバ同士、staticメンバ同士は直接アクセスできる
  - クラス内で定義したインスタンスメンバは、クラス内で定義したstaticメンバに直接アクセスできる
  - クラス内で定義したstaticメンバは、クラス内で定義したインスタンスメンバに直接アクセスできない。
  アクセスする場合は、インスタンス化してからアクセスする。


---
### アクセス修飾子とカプセル化

- アクセス修飾子
  |アクセス修飾子|クラス|コンストラクタ|メンバ変数|メソッド|説明|
  |:---|:---|:---|:---|:---|:---|
  |public|〇|〇|〇|〇|どのクラスからでも利用可能|
  |protected|×|〇|〇|〇|このクラスを継承したサブクラス、もしくは同一パッケージ内のクラスから利用可能|
  |デフォルト(指定なし)|〇|〇|〇|〇|同一パッケージ内のクラスからのみ利用可能|
  |private|×|〇|〇|〇|同一クラス内からのみ利用可能|

- `protected`と`private`は<b>クラスに指定できない</b>

- 推奨されているアクセス制御ルール
  - インスタンス変数は、アクセスをprivateにする
  - メソッドは、アクセスをpublicにする

- publicなクラスは1つのソースファイルにつき、1つしか記述できない。
publicなクラスを定義した場合、そのソースファイル名はpublicなクラスの名前と同じでなければならない
---
### ガベージコレクタ

- プログラムが使用しなくなったメモリ領域を検出し、解放する。

- プログラムの中で明示的にガベージコレクタの対象にするには、`null`を代入する