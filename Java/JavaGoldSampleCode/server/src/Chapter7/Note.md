
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [Chapter7](#chapter7)
  - [継承](#継承)
    - [継承](#継承-1)
    - [オーバーライド](#オーバーライド)
    - [this](#this)
    - [super](#super)

<!-- /code_chunk_output -->


# Chapter7

## 継承

----

### 継承

- 既に定義されたクラスを拡張して新しいクラスを定義すること⇒<b>継承</b>

- 元となるクラスを<b>スーパークラス</b>、新たに作成したクラスを<b>サブクラス</b>という

- `extends`キーワードを使用する
  ```java
  [ 修飾子 ] class サブクラス名 extends スーパークラス名 { }
  ```

- サブクラスをインスタンス化すると、スーパークラスで定義した変数やメソッドが全て引き継がれる
(コンストラクタは引き継がれない)

---
### オーバーライド

- スーパークラスで定義されたメソッド名と全く同じ名前で再定義すること⇒<b>オーバーライド</b>

- オーバーライドのルール
  - メソッド名、引数リストが全く同じメソッドをサブクラスで定義する
  - 戻り値は、スーパークラスで定義したメソッドが返す型と同じか、その型のサブクラス型とする
  - アクセス修飾子は、スーパークラスと同じものか、それよりも公開範囲が広いものであれば使用可能

- オーバーライドはサブクラス側で処理を変えたいという場合に有効

- final修飾子をつけた場合の効果
  - 変数: 定数になる
  - メソッド: サブクラス側でそのメソッドをオーバーライドできなくなる
  - クラス: そのクラスをもとにサブクラスを定義できなくなる

---
### this

- `this`は自分自身(自オブジェクト)を表すキーワード
- 自オブジェクトが保持する変数(インスタンス変数)、メソッド(インスタンスメソッド)、コンストラクタを明示的に指定する際に使用する

- 呼び出されたコンストラクタの中から自クラス内で定義した別のコンストラクタを呼び出すことも可能
その場合は`this()`と記述(`this()`はコンストラクタ定義の先頭に記述する必要あり)


---
### super

- `super`は自オブジェクトから見てスーパークラスのオブジェクトを表現する際に使用

- メソッドをオーバーライドしている場合で、明示的にスーパークラスで定義したほうのメソッドを呼び出したい場合に使用

- サブクラスをインスタンス化すると、まずスーパークラスのコンストラクタが(暗黙的に)呼び出される
この時、明示的に呼び出したいコンストラクタがある場合は`super(引数リスト)`を記述することで実現可能

